/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => JellySnippets
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  snippetsFile: String.raw`Snip me! |+| Snippet successfully replaced.
-==-
- |+| #####
-==-
: |+| -
-==-
:: |+| hi`,
  triggerOnSpace: "disabled" /* Disabled */,
  triggerOnEnter: "disabled" /* Disabled */,
  triggerOnTab: "disabled" /* Disabled */,
  snippetPartDivider: " |+| ",
  snippetDivider: "-==-"
  // postSnippetCursorSymbol: "%move%", // TODO: Actually implement this symbol.
};
var JellySnippets = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.multilineSnippets = {};
  }
  async onload() {
    await this.loadSettings();
    console.log("load");
    this.reloadSnippets();
    if (this.settings.triggerOnSpace !== "disabled" /* Disabled */ || this.settings.triggerOnTab !== "disabled" /* Disabled */ || this.settings.triggerOnEnter !== "disabled" /* Disabled */) {
      const onKeyEvent = (evt) => {
        if (!evt.shiftKey) {
          const mdFile = this.app.workspace.activeEditor;
          if (mdFile == null ? void 0 : mdFile.editor) {
            this.triggerSnippetAutomatically(mdFile.editor, evt);
          }
        }
      };
      this.registerDomEvent(document, "keydown", onKeyEvent);
      this.registerEvent(
        this.app.workspace.on("window-open", (event) => {
          this.registerDomEvent(activeWindow, "keydown", onKeyEvent);
        })
      );
    }
    console.log("load 2");
    this.addCommand({
      id: "trigger-snippet",
      name: "Trigger snippet",
      editorCallback: (editor) => {
        this.triggerSnippet(editor);
      }
    });
    this.addCommand({
      id: "reload-snippets",
      name: "Reload snippets",
      callback: () => {
        this.reloadSnippets();
      }
    });
    this.addSettingTab(new JellySnippetsSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  reloadSnippets() {
    console.log("reloading");
    this.multilineSnippets = {};
    this.parseSnippets();
  }
  parseSnippets() {
    let snippetDivider = this.settings.snippetDivider == "\\n" ? "\n" : this.settings.snippetDivider;
    let snippetLines = this.settings.snippetsFile.split(snippetDivider);
    for (let snippet of snippetLines) {
      let snippetParts = snippet.trim().split(this.settings.snippetPartDivider);
      let lhs = snippetParts.shift();
      console.log(lhs);
      let rhs = snippetParts.join(this.settings.snippetPartDivider);
      if (lhs === void 0) {
        console.log("Failed to register snippet: ", snippet);
      } else {
        this.multilineSnippets[lhs] = rhs;
      }
    }
    console.log(this.multilineSnippets);
  }
  triggerSnippet(editor, pos) {
    let curpos = pos ? pos : editor.getCursor();
    return this.triggerMultilineSnippet(editor, curpos);
  }
  triggerSnippetAutomatically(editor, evt) {
    switch (evt.key) {
      case " ": {
        if (this.settings.triggerOnSpace !== "disabled" /* Disabled */) {
          if (this.triggerSnippet(editor)) {
            return true;
          }
        }
        break;
      }
      case "Tab": {
        if (this.settings.triggerOnTab === "disabled" /* Disabled */) {
          return false;
        }
        editor.exec("indentLess");
        let maybeSnippet = this.triggerSnippet(editor);
        if (maybeSnippet) {
          if (this.settings.triggerOnTab === "y-ws" /* EnabledYesWS */) {
            if (this.getSnippetType(maybeSnippet) === 0 /* SLSR */) {
              editor.exec("indentMore");
            }
          }
          return true;
        } else {
          editor.exec("indentMore");
        }
        break;
      }
      case "Enter": {
        if (this.settings.triggerOnEnter === "disabled" /* Disabled */) {
          return false;
        }
        let curpos = editor.getCursor();
        let aboveline = curpos.line - 1;
        let abovelineEnd = editor.getLine(aboveline).length;
        let peekPos = {
          line: aboveline,
          ch: abovelineEnd
        };
        let maybeSnippet = this.triggerSnippet(editor, peekPos);
        if (maybeSnippet) {
          let snippetType = this.getSnippetType(maybeSnippet);
          if (this.settings.triggerOnEnter === "n-ws" /* EnabledNoWS */) {
            if (snippetType === 2 /* MLSR */) {
            } else {
              let curpos2 = editor.getCursor();
              let nextLine = curpos2.line + 1;
              let nextLineStartPos = {
                line: nextLine,
                ch: 0
              };
              editor.replaceRange("", curpos2, nextLineStartPos);
            }
          } else {
            let curpos2 = editor.getCursor();
            if (snippetType === 2 /* MLSR */) {
              editor.exec("newlineAndIndent");
              editor.exec("indentLess");
            } else {
              editor.exec("goRight");
            }
          }
          return true;
        } else {
          editor.setCursor(curpos);
        }
        break;
      }
      default: {
        break;
      }
    }
    return false;
  }
  triggerMultilineSnippet(editor, pos) {
    const curpos = pos ? pos : editor.getCursor();
    for (let [lhs, rhs] of Object.entries(this.multilineSnippets)) {
      if (!this.selectBackN(editor, lhs.length, curpos)) {
        continue;
      }
      let selected = editor.getSelection();
      if (lhs === selected) {
        editor.replaceSelection(rhs);
        this.unselect(editor);
        return [lhs, rhs];
      }
      this.unselect(editor, curpos);
    }
    return;
  }
  // Motivation:
  // Single snippets (no newlines) and multi snippets (newlines)
  // have different, weird interaction with Obsidian. Sometimes the whitespace goes through, sometimes not.
  // There needs to be a way of determining what type (mlhs->srhs? mlhs->mrhs? slhs? srhs? etc.) a snippet is.
  getSnippetType(snippet) {
    let [lhs, rhs] = snippet;
    let type = 0 /* SLSR */;
    type |= +lhs.contains("\n") && 2 /* MLSR */;
    type |= +rhs.contains("\n") && 1 /* SLMR */;
    return type;
  }
  selectBackN(editor, N, pos) {
    const curpos = pos ? pos : editor.getCursor();
    let endOffset = editor.posToOffset(curpos);
    let startOffset = endOffset - N;
    if (startOffset < 0) {
      return false;
    }
    let startPos = editor.offsetToPos(startOffset);
    let endPos = editor.offsetToPos(endOffset);
    editor.setSelection(startPos, endPos);
    return true;
  }
  unselect(editor, pos) {
    if (pos)
      editor.setSelection(pos, pos);
    else
      editor.setSelection(editor.getCursor(), editor.getCursor());
  }
};
var JellySnippetsSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    let childEl = containerEl.createDiv({ cls: "jelly_snippets" });
    childEl.createEl("h2", { text: "Jelly Snippets - Settings" });
    new import_obsidian.Setting(childEl).setName("Snippets").setDesc(
      "Specify your snippets here! Format: 'before<divider>after'. Surrounding your divider with a space is recommended for readability."
    ).addTextArea(
      (textarea) => textarea.setPlaceholder(
        `before${this.plugin.settings.snippetPartDivider}after`
      ).setValue(this.plugin.settings.snippetsFile).onChange(async (value) => {
        this.plugin.settings.snippetsFile = value;
        await this.plugin.saveSettings();
        this.plugin.reloadSnippets();
      })
    );
    new import_obsidian.Setting(childEl).setName("Snippet line divider").setDesc(
      "This string will divide each separate snippet definition. (Enter the two characters '\\n' to use newlines as your separator.)"
    ).addText(
      (text) => text.setPlaceholder("-==-").setValue(this.plugin.settings.snippetDivider).onChange(async (value) => {
        this.plugin.settings.snippetDivider = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(childEl).setName("Snippet part divider").setDesc(
      "This string will divide the lhs and rhs of a snippet definition. (I recommend putting spaces in the ends of this string.)"
    ).addText(
      (text) => text.setPlaceholder(" |+| ").setValue(this.plugin.settings.snippetPartDivider).onChange(async (value) => {
        this.plugin.settings.snippetPartDivider = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(childEl).setName("Trigger on Space").setDesc(
      "If enabled, the snippet function will trigger when space is pressed (but not while shift is held)."
    ).addDropdown(
      (dropdown) => dropdown.addOption("disabled" /* Disabled */, "Disabled").addOption(
        "y-ws" /* EnabledYesWS */,
        "Enabled, also space"
      ).setValue(this.plugin.settings.triggerOnSpace).onChange(async (value) => {
        this.plugin.settings.triggerOnSpace = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(childEl).setName("Trigger on Enter").setDesc(
      "If enabled, the snippet function will trigger when enter is pressed (but not while shift is held)."
    ).addDropdown(
      (dropdown) => dropdown.addOption("disabled" /* Disabled */, "Disabled").addOption(
        "n-ws" /* EnabledNoWS */,
        "Enabled, no newline"
      ).addOption(
        "y-ws" /* EnabledYesWS */,
        "Enabled, also newline"
      ).setValue(this.plugin.settings.triggerOnEnter).onChange(async (value) => {
        this.plugin.settings.triggerOnEnter = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(childEl).setName("Trigger on Tab").setDesc(
      "If enabled, the snippet function will trigger when tab is pressed (but not while shift is held)."
    ).addDropdown(
      (dropdown) => dropdown.addOption("disabled" /* Disabled */, "Disabled").addOption(
        "n-ws" /* EnabledNoWS */,
        "Enabled, no indent"
      ).addOption(
        "y-ws" /* EnabledYesWS */,
        "Enabled, also indent on simple snippets (no newlines)"
      ).setValue(this.plugin.settings.triggerOnTab).onChange(async (value) => {
        this.plugin.settings.triggerOnTab = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
